// Generated by CoffeeScript 1.6.3
(function() {
  var Break, Closure, Context, Continue, ControlObject, EvaluatorClass, FunctionCall, FunctionDefinition, If, Loop, NewObject, Return, Switch, With, compileExpression, compileStatements,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  compileStatements = function(statements) {
    var body, caseMappings, condition, declarator, declaredFunctions, declaredVariables, defaultIndex, elseClause, instructions, loopInstructions, makeLoopTest, name, object, param, params, statement, subExpression, subInstructions, subStatements, switchCase, testBytecode, testInstructions, thenClause, updateBytecode, value, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
    subExpression = function(toCompile) {
      var compiled;
      if (toCompile === null) {
        return null;
      }
      compiled = compileExpression(toCompile);
      $.merge(instructions, compiled.preInstructions);
      return compiled.expression;
    };
    subStatements = function(toCompile) {
      var bytecode, name, _i, _len, _ref;
      if (toCompile === null) {
        return [];
      }
      if (!$.isArray(toCompile)) {
        toCompile = [toCompile];
      }
      bytecode = compileStatements(toCompile);
      _ref = bytecode.declaredVariables;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        declaredVariables[name] = 1;
      }
      $.merge(declaredFunctions, bytecode.declaredFunctions);
      return bytecode.instructions;
    };
    makeLoopTest = function(test) {
      var instructions, loopTest, negatedCondition, testBytecode;
      testBytecode = compileExpression(test);
      instructions = testBytecode.preInstructions;
      negatedCondition = "!(" + testBytecode.expression + ")";
      loopTest = new If(negatedCondition, [new Break()], []);
      return $.merge(instructions, [loopTest]);
    };
    instructions = [];
    declaredVariables = {};
    declaredFunctions = [];
    for (_i = 0, _len = statements.length; _i < _len; _i++) {
      statement = statements[_i];
      switch (statement.type) {
        case "ExpressionStatement":
          instructions.push(subExpression(statement.expression));
          break;
        case "VariableDeclaration":
          _ref = statement.declarations;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            declarator = _ref[_j];
            name = subExpression(declarator.id);
            declaredVariables[name] = 1;
            if (declarator.init !== null) {
              instructions.push(name + " = " + subExpression(declarator.init));
            }
          }
          break;
        case "FunctionDeclaration":
          name = subExpression(statement.id);
          params = (function() {
            var _k, _len2, _ref1, _results;
            _ref1 = statement.params;
            _results = [];
            for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
              param = _ref1[_k];
              _results.push(subExpression(param));
            }
            return _results;
          })();
          body = compileStatements([statement.body]);
          declaredFunctions.push(new FunctionDefinition(name, params, body));
          break;
        case "ReturnStatement":
          value = subExpression(statement.argument);
          instructions.push(new Return(value));
          break;
        case "BlockStatement":
          $.merge(instructions, subStatements(statement.body));
          break;
        case "IfStatement":
          condition = subExpression(statement.test);
          thenClause = subStatements(statement.consequent);
          elseClause = subStatements(statement.alternate);
          instructions.push(new If(condition, thenClause, elseClause));
          break;
        case "LabeledStatement":
          $.merge(instructions, subStatements(statement.body));
          break;
        case "BreakStatement":
          if (statement.label !== null) {
            throw new Error("Does not support labelled breaks.");
          }
          instructions.push(new Break());
          break;
        case "ContinueStatement":
          if (statement.label !== null) {
            throw new Error("Does not support labelled continues.");
          }
          instructions.push(new Continue());
          break;
        case "WithStatement":
          object = subExpression(statement.object);
          body = subStatements(statement.body);
          instructions.push(new With(object, body));
          break;
        case "SwitchStatement":
          value = subExpression(statement.discriminant);
          subInstructions = [];
          caseMappings = [];
          defaultIndex = null;
          _ref1 = statement.cases;
          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
            switchCase = _ref1[_k];
            if (switchCase.test !== null) {
              testBytecode = compileExpression(switchCase.test);
              testInstructions = $.merge(testBytecode.preInstructions, [new Return(testBytecode.expression)]);
              body = {
                declaredFunctions: [],
                declaredVariables: [],
                instructions: testInstructions
              };
              caseMappings.push({
                test: new FunctionDefinition(null, [], body),
                index: subInstructions.length
              });
            } else {
              defaultIndex = subInstructions.length;
            }
            $.merge(subInstructions, subStatements(switchCase.consequent));
          }
          instructions.push(new Switch(value, subInstructions, caseMappings, defaultIndex));
          break;
        case "WhileStatement":
          loopInstructions = [];
          $.merge(loopInstructions, makeLoopTest(statement.test));
          $.merge(loopInstructions, subStatements(statement.body));
          instructions.push(new Loop(loopInstructions));
          break;
        case "DoWhileStatement":
          loopInstructions = [];
          $.merge(loopInstructions, subStatements(statement.body));
          $.merge(loopInstructions, makeLoopTest(statement.test));
          instructions.push(new Loop(loopInstructions));
          break;
        case "ForStatement":
          if (statement.init !== null) {
            if (statement.init.type === "VariableDeclaration") {
              $.merge(instructions, subStatements(statement.init));
            } else {
              instructions.push(subExpression(statement.init));
            }
          }
          loopInstructions = [];
          if (statement.test !== null) {
            $.merge(loopInstructions, makeLoopTest(statement.test));
          }
          $.merge(loopInstructions, subStatements(statement.body));
          if (statement.update !== null) {
            updateBytecode = compileExpression(statement.update);
            $.merge(loopInstructions, updateBytecode.preInstructions);
            loopInstructions.push(updateBytecode.expression);
          }
          instructions.push(new Loop(loopInstructions));
      }
    }
    return {
      instructions: instructions,
      declaredVariables: Object.keys(declaredVariables),
      declaredFunctions: declaredFunctions
    };
  };

  compileExpression = function(expression, currentTemp) {
    var Cls, alternate, arg, args, body, callee, compiled, consequent, element, elements, extraInstructions, getTempVariable, left, name, object, operator, param, params, properties, property, right, separator, subExpression, tempVar, test, _i, _len, _ref;
    subExpression = function(toCompile) {
      var compiled;
      compiled = compileExpression(toCompile, currentTemp);
      $.merge(extraInstructions, compiled.preInstructions);
      return compiled.expression;
    };
    getTempVariable = function() {
      return "$__temp__[" + (currentTemp.val++) + "]";
    };
    extraInstructions = [];
    currentTemp = currentTemp || {
      val: 0
    };
    switch (expression.type) {
      case "ThisExpression":
        compiled = "this";
        break;
      case "Literal":
        compiled = expression.raw;
        break;
      case "Identifier":
        compiled = expression.name;
        break;
      case "ArrayExpression":
        elements = (function() {
          var _i, _len, _ref, _results;
          _ref = expression.elements;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            element = _ref[_i];
            _results.push(subExpression(element));
          }
          return _results;
        })();
        compiled = "[" + elements.join(", ") + "]";
        break;
      case "ObjectExpression":
        properties = [];
        _ref = expression.properties;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          property = _ref[_i];
          properties.push(subExpression(property.key) + ": " + subExpression(property.value));
        }
        compiled = "({" + properties.join(", ") + "})";
        break;
      case "FunctionExpression":
        name = (expression.id !== null ? subExpression(expression.id) : null);
        params = (function() {
          var _j, _len1, _ref1, _results;
          _ref1 = expression.params;
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            param = _ref1[_j];
            _results.push(subExpression(param));
          }
          return _results;
        })();
        body = compileStatements([expression.body]);
        tempVar = getTempVariable();
        extraInstructions.push(new FunctionDefinition(name, params, body, tempVar));
        compiled = tempVar;
        break;
      case "SequenceExpression":
        elements = (function() {
          var _j, _len1, _ref1, _results;
          _ref1 = expression.expressions;
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            element = _ref1[_j];
            _results.push(subExpression(element));
          }
          return _results;
        })();
        compiled = elements.join(", ");
        break;
      case "UnaryExpression":
        operator = expression.operator;
        separator = (operator.length > 1 ? " " : "");
        compiled = operator + separator + subExpression(expression.argument);
        break;
      case "BinaryExpression":
      case "AssignmentExpression":
      case "LogicalExpression":
        left = subExpression(expression.left);
        right = subExpression(expression.right);
        compiled = "(" + left + " " + expression.operator + " " + right + ")";
        break;
      case "UpdateExpression":
        compiled = subExpression(expression.argument);
        if (expression.prefix) {
          compiled = expression.operator + compiled;
        } else {
          compiled += expression.operator;
        }
        break;
      case "ConditionalExpression":
        test = subExpression(expression.test);
        consequent = subExpression(expression.consequent);
        alternate = subExpression(expression.alternate);
        compiled = test + " ? " + consequent + " : " + alternate;
        break;
      case "MemberExpression":
        property = subExpression(expression.property);
        object = subExpression(expression.object);
        if (expression.computed) {
          compiled = object + "[" + property + "]";
        } else {
          compiled = object + "." + property;
        }
        break;
      case "CallExpression":
      case "NewExpression":
        Cls = (expression.type === "CallExpression" ? FunctionCall : NewObject);
        callee = subExpression(expression.callee);
        args = (function() {
          var _j, _len1, _ref1, _results;
          _ref1 = expression["arguments"];
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            arg = _ref1[_j];
            _results.push(subExpression(arg));
          }
          return _results;
        })();
        tempVar = getTempVariable();
        extraInstructions.push(new Cls(callee, args, tempVar));
        compiled = tempVar;
    }
    return {
      preInstructions: extraInstructions,
      expression: compiled
    };
  };

  ControlObject = (function() {
    function ControlObject() {}

    ControlObject.prototype.updateState = function() {};

    ControlObject.prototype.canBreak = function() {
      return false;
    };

    ControlObject.prototype.canContinue = function() {
      return false;
    };

    ControlObject.prototype.canReturn = function() {
      return false;
    };

    return ControlObject;

  })();

  Closure = (function() {
    function Closure(func, env) {
      this["function"] = func;
      this.environment = env;
    }

    Closure.prototype.getInstructions = function() {
      return this["function"].body.instructions;
    };

    Closure.prototype.getEnvironment = function(args) {
      var i, newEnvironmentFrame, param, variable, _i, _j, _len, _len1, _ref, _ref1;
      newEnvironmentFrame = {};
      _ref = this["function"].body.declaredVariables;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        variable = _ref[_i];
        newEnvironmentFrame[variable] = void 0;
      }
      _ref1 = this["function"].params;
      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
        param = _ref1[i];
        newEnvironmentFrame[param] = args[i];
      }
      return this.environment.concat([newEnvironmentFrame]);
    };

    return Closure;

  })();

  FunctionDefinition = (function() {
    function FunctionDefinition(name, params, body, tempVar) {
      this.name = name;
      this.params = params;
      this.body = body;
      this.tempVar = tempVar || null;
    }

    FunctionDefinition.prototype.updateState = function(context) {
      return context.setValue(this.tempVar, new Closure(this, context.getEnvironment()));
    };

    return FunctionDefinition;

  })();

  FunctionCall = (function() {
    function FunctionCall(callee, args, tempVar) {
      this.callee = callee;
      this.args = args;
      this.tempVar = tempVar;
    }

    FunctionCall.prototype.updateState = function(context) {
      var arg, argValues, func;
      func = context["eval"](this.callee);
      if (func instanceof Closure) {
        argValues = (function() {
          var _i, _len, _ref, _results;
          _ref = this.args;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            arg = _ref[_i];
            _results.push(context["eval"](arg));
          }
          return _results;
        }).call(this);
        return context.pushState(func.getInstructions(), this, func.getEnvironment(argValues));
      } else {
        return context["eval"](this.tempVar + " = " + this.callee + "(" + this.args.join(", ") + ")");
      }
    };

    FunctionCall.prototype.canReturn = function() {
      return true;
    };

    FunctionCall.prototype.handleReturn = function(context, value) {
      return context.setValue(this.tempVar, value);
    };

    return FunctionCall;

  })();

  NewObject = (function() {
    function NewObject(callee, args, tempVar) {
      this.callee = callee;
      this.args = args;
      this.tempVar = tempVar;
    }

    return NewObject;

  })();

  Return = (function() {
    function Return(value) {
      this.value = value;
    }

    Return.prototype.updateState = function(context) {
      var returnValue, returner;
      returnValue = context["eval"](this.value);
      while (!context.getControlObject().canReturn()) {
        context.popState();
      }
      returner = context.getControlObject();
      context.popState();
      return returner.handleReturn(context, returnValue);
    };

    return Return;

  })();

  If = (function(_super) {
    __extends(If, _super);

    function If(condition, thenClause, elseClause) {
      this.condition = condition;
      this.thenCase = thenClause;
      this.elseCase = elseClause;
    }

    If.prototype.updateState = function(context) {
      var instructions;
      instructions = (context["eval"](this.condition) ? this.thenCase : this.elseCase);
      return context.pushState(instructions, this);
    };

    return If;

  })(ControlObject);

  With = (function() {
    function With(object, body) {
      this.object = object;
      this.body = body;
    }

    return With;

  })();

  Switch = (function() {
    function Switch(value, instructions, cases, defaultIndex) {
      this.value = value;
      this.instructions = instructions;
      this.cases = cases;
      this["default"] = defaultIndex || null;
    }

    return Switch;

  })();

  Break = (function() {
    function Break() {}

    Break.prototype.updateState = function(context) {
      while (!context.getControlObject().canBreak()) {
        context.popState();
      }
      return context.popState();
    };

    return Break;

  })();

  Continue = (function() {
    function Continue() {}

    Continue.prototype.updateState = function(context) {
      while (!context.getControlObject().canContinue()) {
        context.popState();
      }
      return context.setPC(0);
    };

    return Continue;

  })();

  Loop = (function(_super) {
    __extends(Loop, _super);

    function Loop(instructions) {
      this.instructions = instructions;
      this.instructions.push(new Continue());
    }

    Loop.prototype.updateState = function(context) {
      return context.pushState(this.instructions, this);
    };

    Loop.prototype.canContinue = function() {
      return true;
    };

    Loop.prototype.canBreak = function() {
      return true;
    };

    return Loop;

  })(ControlObject);

  /*
  Context class, contains the execution context and wrappers to interact
  with the various elements of the execution context. An execution context
  is comprised of a series of states, accessed in a first-in-first-out order,
  or in other words, a stack of states. Each state consists of a list of
  instructions, a program counter (pc) which is the index of the next
  instruction, a control object, which is the control structure that is
  responsible for the current block of instructions, and an environment,
  which is an array of dictionaries that represent the lookup chain for
  variables in the state.
  
  The 'scope' argument in the constructor should be an instance of a window
  object, which has an eval function that can be used to evaluate code in a
  sandboxed fashion.
  */


  Context = (function() {
    function Context(scope) {
      this.scope = scope;
      this.state = [];
    }

    Context.prototype["eval"] = function(command) {
      var environment, i, postWrap, preWrap, _i, _ref;
      environment = this.getEnvironment();
      this.scope["$__env__"] = environment;
      preWrap = "";
      postWrap = "";
      for (i = _i = 0, _ref = environment.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        preWrap += "with($__env__[" + i + "]){";
        postWrap += "}";
      }
      command = preWrap + command + postWrap;
      return this.scope["eval"](command);
    };

    Context.prototype.pushState = function(instructions, controlObject, environment) {
      return this.state.push({
        instructions: instructions,
        pc: 0,
        controlObject: controlObject || null,
        environment: environment || []
      });
    };

    Context.prototype.popState = function() {
      return this.state.pop();
    };

    Context.prototype.getCurrentState = function() {
      if (this.state.length > 0) {
        return this.state[this.state.length - 1];
      } else {
        return {
          instructions: [],
          pc: 0,
          controlObject: null,
          environment: []
        };
      }
    };

    Context.prototype.hasMoreInstructions = function() {
      var currentState;
      currentState = this.getCurrentState();
      return currentState.instructions.length > currentState.pc;
    };

    Context.prototype.getNextInstruction = function() {
      var currentState, instruction;
      currentState = this.getCurrentState();
      instruction = currentState.instructions[currentState.pc];
      currentState.pc++;
      return instruction;
    };

    Context.prototype.finishedExecution = function() {
      return this.state.length === 0;
    };

    Context.prototype.getControlObject = function() {
      return this.getCurrentState().controlObject;
    };

    Context.prototype.setPC = function(newPC) {
      return this.getCurrentState().pc = newPC;
    };

    Context.prototype.getEnvironment = function() {
      return this.getCurrentState().environment;
    };

    Context.prototype.setValue = function(name, value) {
      this.scope["$__result__"] = value;
      return this["eval"](name + " = $__result__");
    };

    return Context;

  })();

  EvaluatorClass = (function() {
    function EvaluatorClass() {
      var iframe;
      iframe = $("<iframe width=\"0\" height=\"0\"></iframe>").css({
        visibility: "hidden"
      }).appendTo("body").get(0);
      this.context = new Context(iframe.contentWindow);
      iframe.contentWindow["$__temp__"] = [];
    }

    EvaluatorClass.prototype["eval"] = function(string) {
      var ast, bytecode;
      this.isRunning = true;
      ast = esprima.parse(string).body;
      bytecode = compileStatements(ast);
      this.context.pushState(bytecode.instructions);
      return this.execute();
    };

    EvaluatorClass.prototype.execute = function() {
      var instruction, lastResult;
      instruction = void 0;
      lastResult = void 0;
      while (!this.context.finishedExecution()) {
        while (this.context.hasMoreInstructions()) {
          if (!this.isRunning) {
            return;
          }
          instruction = this.context.getNextInstruction();
          if (typeof instruction === "string") {
            lastResult = this.context["eval"](instruction);
          } else {
            instruction.updateState(this.context);
          }
        }
        this.context.popState();
      }
      return lastResult;
    };

    EvaluatorClass.prototype.pause = function() {
      return this.isRunning = false;
    };

    EvaluatorClass.prototype.resume = function() {
      this.isRunning = true;
      return this.execute();
    };

    return EvaluatorClass;

  })();

  EvaluatorClass.prototype.compileStatements = compileStatements;

  EvaluatorClass.prototype.compileExpression = compileExpression;

  EvaluatorClass.prototype.Function = FunctionDefinition;

  EvaluatorClass.prototype.FunctionCall = FunctionCall;

  EvaluatorClass.prototype.NewObject = NewObject;

  EvaluatorClass.prototype.Return = Return;

  EvaluatorClass.prototype.Continue = Continue;

  EvaluatorClass.prototype.Break = Break;

  EvaluatorClass.prototype.If = If;

  EvaluatorClass.prototype.With = With;

  EvaluatorClass.prototype.Switch = Switch;

  EvaluatorClass.prototype.Loop = Loop;

  window.Evaluator = EvaluatorClass;

}).call(this);
