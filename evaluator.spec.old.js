// Generated by CoffeeScript 1.6.3
(function() {
  describe("The evaluator module", function() {
    var evaluator;
    evaluator = void 0;
    beforeEach(function() {
      return evaluator = new Evaluator();
    });
    afterEach(function() {
      var iframe;
      iframe = evaluator.context.scope.frameElement;
      return iframe.parentElement.removeChild(iframe);
    });
    it("creates an iframe to evaluate code in", function() {
      var iframe, isIFrame;
      iframe = evaluator.context.scope.frameElement;
      isIFrame = iframe instanceof HTMLIFrameElement || iframe instanceof evaluator.context.scope.HTMLIFrameElement;
      expect(isIFrame).toBe(true);
      expect(iframe.height).toEqual("0");
      expect(iframe.width).toEqual("0");
      return expect(iframe.style.visibility).toEqual("hidden");
    });
    it("creates a temporary variable array in the global scope", function() {
      return expect(evaluator.context["eval"]("$__temp__")).toEqual([]);
    });
    describe("when compiling", function() {
      var expectAstEqual, expectFunctionCall, expectFunctionDef, getExpressionBytecode, getStatementsBytecode, tempName;
      getExpressionBytecode = function(expressionString) {
        var body;
        body = esprima.parse(expressionString).body;
        expect(body.length).toEqual(1);
        expect(body[0].type).toEqual("ExpressionStatement");
        return evaluator.compileExpression(body[0].expression);
      };
      getStatementsBytecode = function(statementsString) {
        var ast;
        ast = esprima.parse(statementsString).body;
        return evaluator.compileStatements(ast);
      };
      expectFunctionDef = function(func, name, params, body, tempVar) {
        var bodyInstructions, functionBytecode;
        expect(func).toEqual(jasmine.any(evaluator.Function));
        expect(func.name).toEqual(name);
        expect(func.params).toEqual(params);
        expect(func.tempVar).toEqual(tempVar);
        functionBytecode = getExpressionBytecode("(function () {" + body + "})");
        bodyInstructions = functionBytecode.preInstructions[0].body;
        return expect(func.body).toEqual(bodyInstructions);
      };
      expectFunctionCall = function(functionCall, callee, args, tempVar, isObjectCreation) {
        var targetClass;
        isObjectCreation = !!isObjectCreation;
        targetClass = (isObjectCreation ? evaluator.NewObject : evaluator.FunctionCall);
        expect(functionCall).toEqual(jasmine.any(targetClass));
        expect(functionCall.callee).toEqual(callee);
        expect(functionCall.args.length).toEqual(args.length);
        $.each(functionCall.args, function(i, arg) {
          return expectAstEqual(arg, args[i]);
        });
        return expect(functionCall.tempVar).toEqual(tempVar);
      };
      expectAstEqual = function(actual, expected) {
        var actualAst, expectedAst;
        actualAst = esprima.parse(actual).body;
        expectedAst = esprima.parse(expected).body;
        return expect(actualAst).toEqual(expectedAst);
      };
      tempName = function(index) {
        return "$__temp__[" + index + "]";
      };
      describe("expression bytecode", function() {
        var expressionExpectNoChange;
        expressionExpectNoChange = function(expressionString) {
          var body, bytecode, e, reParsed;
          try {
            body = esprima.parse(expressionString).body;
            expect(body.length).toEqual(1);
            expect(body[0].type).toEqual("ExpressionStatement");
            bytecode = evaluator.compileExpression(body[0].expression);
            expect(bytecode.preInstructions).toEqual([]);
            reParsed = esprima.parse(bytecode.expression).body;
            return expect(reParsed).toEqual(body);
          } catch (_error) {
            e = _error;
            throw new Error("Failed to compile " + expressionString + ". Error is: " + e.toString());
          }
        };
        it("converts non-function calls to a string", function() {
          var original;
          original = ["\"my string\"", "true", "null", "123.45", "1.0e2", "/regex/", "$my_id_", "this", "[1, true, \"hi\", foo]", "({a: 1})", "({msg: \"hello\", arr: [1,2,3], obj: {foo: \"bar\"}})", "1, 2, red, blue", "-a", "+5", "!hello", "~true", "! \"hey\"", "typeof obj", "void \"hi\"", "delete foo", "a in b", "\"0\" == false", "foo = 12", "i += 4", "a++", "b--", "++c", "--d", "true || false", "a && b || c", "useSpace ? \" \" : \"\"", "a && b ? 15 : 25", "a.b", "foo[bar]", "arr[0]", "obj[\"key\"]", "(1 + 2) * 3", "a && (b || c)", "1"];
          return $.each(original, function(i, expression) {
            return expressionExpectNoChange(expression);
          });
        });
        it("can define functions", function() {
          var body, bytecode, func, original, temp;
          temp = tempName(0);
          original = "(function () {var a = {hi: \"hello\"}; a.b = 123; var b = \"foo\"})";
          bytecode = getExpressionBytecode(original);
          expect(bytecode.preInstructions.length).toEqual(1);
          func = bytecode.preInstructions[0];
          body = "var a = {hi: \"hello\"}; a.b = 123; var b = \"foo\"";
          expectFunctionDef(func, null, [], body, temp);
          expect(bytecode.expression).toEqual(temp);
          original = "(function foo(a, b) {a + b})";
          bytecode = getExpressionBytecode(original);
          expect(bytecode.preInstructions.length).toEqual(1);
          func = bytecode.preInstructions[0];
          expectFunctionDef(func, "foo", ["a", "b"], "a + b", temp);
          return expect(bytecode.expression).toEqual(temp);
        });
        it("can call functions", function() {
          var bytecode, funcCall, temp;
          temp = tempName(0);
          bytecode = getExpressionBytecode("a.b.c()");
          expect(bytecode.preInstructions.length).toEqual(1);
          funcCall = bytecode.preInstructions[0];
          expectFunctionCall(funcCall, "a.b.c", [], temp);
          expect(bytecode.expression).toEqual(temp);
          bytecode = getExpressionBytecode("func(foo, bar)");
          expect(bytecode.preInstructions.length).toEqual(1);
          funcCall = bytecode.preInstructions[0];
          expectFunctionCall(funcCall, "func", ["foo", "bar"], temp);
          return expect(bytecode.expression).toEqual(temp);
        });
        it("can create new objects", function() {
          var bytecode, newObj, temp;
          temp = tempName(0);
          bytecode = getExpressionBytecode("new foo(a, b, c)");
          expect(bytecode.preInstructions.length).toEqual(1);
          newObj = bytecode.preInstructions[0];
          expectFunctionCall(newObj, "foo", ["a", "b", "c"], temp, true);
          return expect(bytecode.expression).toEqual(temp);
        });
        return it("handles multiple pre-instructions", function() {
          var bytecode, t0, t1;
          t0 = tempName(0);
          t1 = tempName(1);
          bytecode = getExpressionBytecode("[foo(), bar()]");
          expect(bytecode.preInstructions.length).toEqual(2);
          expectFunctionCall(bytecode.preInstructions[0], "foo", [], t0);
          expectFunctionCall(bytecode.preInstructions[1], "bar", [], t1);
          expectAstEqual(bytecode.expression, "[" + t0 + ", " + t1 + "]");
          bytecode = getExpressionBytecode("obj.baz(a).garply(b).length");
          expect(bytecode.preInstructions.length).toEqual(2);
          expectFunctionCall(bytecode.preInstructions[0], "obj.baz", ["a"], t0);
          expectFunctionCall(bytecode.preInstructions[1], t0 + ".garply", ["b"], t1);
          expect(bytecode.expression).toEqual(t1 + ".length");
          bytecode = getExpressionBytecode("outer(inner())");
          expect(bytecode.preInstructions.length).toEqual(2);
          expectFunctionCall(bytecode.preInstructions[0], "inner", [], t0);
          expectFunctionCall(bytecode.preInstructions[1], "outer", [t0], t1);
          return expect(bytecode.expression).toEqual(t1);
        });
      });
      return describe("statement bytecode", function() {
        /*
        Ensures that statements are compiled properly
        */

        var expectStatementsEqual;
        expectStatementsEqual = function(program, expectedStatements, expectedVariables, expectedFunctions) {
          var bytecode, compiled;
          expectedVariables = expectedVariables || [];
          expectedFunctions = expectedFunctions || [];
          bytecode = getStatementsBytecode(program);
          compiled = bytecode.instructions;
          expect(bytecode.declaredVariables.sort()).toEqual(expectedVariables.sort());
          expect(bytecode.declaredFunctions.length).toEqual(expectedFunctions.length);
          $.each(bytecode.declaredFunctions, function(i, actualFunc) {
            var functionInformation;
            functionInformation = $.merge([actualFunc], expectedFunctions[i]);
            return expectFunctionDef.apply(null, functionInformation);
          });
          expect(compiled.length).toEqual(expectedStatements.length);
          return $.each(compiled, function(i, c) {
            var cParsed, eParsed;
            cParsed = esprima.parse(c);
            eParsed = esprima.parse(expectedStatements[i]);
            return expect(cParsed).toEqual(eParsed);
          });
        };
        it("ignores empty statements", function() {
          return expectStatementsEqual(";", []);
        });
        it("puts expressions in their own instruction", function() {
          return expectStatementsEqual("a; 1 + 2; foo = \"hi\"", ["a", "1 + 2", "foo = \"hi\""]);
        });
        it("puts an expression's pre instructions before the instruction", function() {
          var bytecode, original, t0, t1;
          t0 = tempName(0);
          t1 = tempName(1);
          original = "var a = 5; b = f(a, g());";
          bytecode = getStatementsBytecode(original);
          expect(bytecode.declaredVariables).toEqual(["a"]);
          expect(bytecode.instructions.length).toEqual(4);
          expectAstEqual(bytecode.instructions[0], "a = 5");
          expectFunctionCall(bytecode.instructions[1], "g", [], t0);
          expectFunctionCall(bytecode.instructions[2], "f", ["a", t0], t1);
          return expectAstEqual(bytecode.instructions[3], "b = " + t1);
        });
        it("extracts declared variables", function() {
          return expectStatementsEqual("a = 1; var b = 2, c; var a; b++", ["a = 1", "b = 2", "b++"], ["a", "b", "c"]);
        });
        it("extracts declared functions", function() {
          var bytecode, declaredFuncs, original;
          original = "" + "obj = {msg: \"hi\"};" + "function foo(a, b) {" + "  a[b] = \"foo\"" + "}" + "var bar = function bar() {};";
          bytecode = getStatementsBytecode(original);
          expect(bytecode.declaredVariables).toEqual(["bar"]);
          declaredFuncs = bytecode.declaredFunctions;
          expect(declaredFuncs.length).toEqual(1);
          expectFunctionDef(declaredFuncs[0], "foo", ["a", "b"], "a[b] = \"foo\"", null);
          expect(bytecode.instructions.length).toEqual(3);
          expectAstEqual(bytecode.instructions[0], "obj = {msg: \"hi\"}");
          expectFunctionDef(bytecode.instructions[1], "bar", [], "", tempName(0));
          return expectAstEqual(bytecode.instructions[2], "bar = " + tempName(0));
        });
        it("can return values from functions", function() {
          var bytecode, func, returnInst;
          bytecode = getExpressionBytecode("(function () {return 5})");
          func = bytecode.preInstructions[0];
          returnInst = func.body.instructions[0];
          expect(returnInst).toEqual(jasmine.any(evaluator.Return));
          return expect(returnInst.value).toEqual("5");
        });
        it("flattens block statements", function() {
          return expectStatementsEqual("a = 1; {b = 2; var b, c = 3; function foo() {}}; var c = 4;", ["a = 1", "b = 2", "c = 3", "c = 4"], ["b", "c"], [["foo", [], "", null]]);
        });
        it("creates if statements with function scope", function() {
          var bytecode, declaredFuncs, ifStatement;
          bytecode = getStatementsBytecode("var myval = \"hi\";" + "if (!isHi(myval)) {" + "  var a = 1;" + "} else {" + "  var b = 2;" + "  function inside() {}" + "}" + "function isHi(val) {return val === \"hi\"}" + "var c = \"hello\";");
          expect(bytecode.declaredVariables).toEqual(["myval", "a", "b", "c"]);
          declaredFuncs = bytecode.declaredFunctions;
          expect(declaredFuncs.length).toEqual(2);
          expectFunctionDef(declaredFuncs[0], "inside", [], "", null);
          expectFunctionDef(declaredFuncs[1], "isHi", ["val"], "return val === \"hi\"", null);
          expect(bytecode.instructions.length).toEqual(4);
          expectAstEqual(bytecode.instructions[0], "myval = \"hi\"");
          expectFunctionCall(bytecode.instructions[1], "isHi", ["myval"], tempName(0));
          ifStatement = bytecode.instructions[2];
          expect(ifStatement).toEqual(jasmine.any(evaluator.If));
          expectAstEqual(ifStatement.condition, "!" + tempName(0));
          expect(ifStatement.thenCase.length).toEqual(1);
          expectAstEqual(ifStatement.thenCase[0], "a = 1");
          expect(ifStatement.elseCase.length).toEqual(1);
          expectAstEqual(ifStatement.elseCase[0], "b = 2");
          return expectAstEqual(bytecode.instructions[3], "c = \"hello\"");
        });
        it("handles if statements without else blocks", function() {
          var bytecode, ifStatement;
          bytecode = getStatementsBytecode("if (predicate) {" + "  a = 1;" + "}");
          expect(bytecode.instructions.length).toEqual(1);
          ifStatement = bytecode.instructions[0];
          expect(ifStatement.thenCase.length).toEqual(1);
          expectAstEqual(ifStatement.thenCase[0], "a = 1");
          return expect(ifStatement.elseCase).toEqual([]);
        });
        it("ignores labels", function() {
          var original;
          original = "foo:" + "{" + "  a = 1;" + "  bar: a++" + "}";
          return expectStatementsEqual(original, ["a = 1", "a++"]);
        });
        it("creates With blocks with function scope", function() {
          var bytecode;
          bytecode = getStatementsBytecode("with (getEnv()) {" + "  var a = 1;" + "  function b () {}" + "}");
          expect(bytecode.declaredVariables).toEqual(["a"]);
          expect(bytecode.declaredFunctions.length).toEqual(1);
          expectFunctionDef(bytecode.declaredFunctions[0], "b", [], "", null);
          return expect(bytecode.instructions).toEqual([new evaluator.FunctionCall("getEnv", [], tempName(0)), new evaluator.With(tempName(0), ["a = 1"])]);
        });
        describe("creating Switch blocks", function() {
          it("flattens all cases into a single array of statements", function() {
            var bytecode, inst, switchStatement;
            bytecode = getStatementsBytecode("switch (val) {" + "case first:" + "  a = 2;" + "  a++;" + "case \"second\":" + "  a = 5;" + "  b(a);" + "}");
            expect(bytecode.instructions.length).toEqual(1);
            switchStatement = bytecode.instructions[0];
            expect(switchStatement).toEqual(jasmine.any(evaluator.Switch));
            expect(switchStatement.value).toEqual("val");
            inst = switchStatement.instructions;
            expectAstEqual(inst[0], "a = 2");
            expectAstEqual(inst[1], "a++");
            expectAstEqual(inst[2], "a = 5");
            expectFunctionCall(inst[3], "b", ["a"], tempName(0));
            return expectAstEqual(inst[4], tempName(0));
          });
          it("has function scope", function() {
            var bytecode, inst;
            bytecode = getStatementsBytecode("switch (foo().val) {" + "case first:" + "  var a = 2;" + "case \"second\":" + "  var b = 5;" + "  function c(d) {e}" + "}");
            expect(bytecode.declaredVariables).toEqual(["a", "b"]);
            expect(bytecode.declaredFunctions.length).toEqual(1);
            expectFunctionDef(bytecode.declaredFunctions[0], "c", ["d"], "e", null);
            inst = bytecode.instructions;
            expect(inst.length).toEqual(2);
            expectFunctionCall(inst[0], "foo", [], tempName(0));
            expect(inst[1]).toEqual(jasmine.any(evaluator.Switch));
            return expect(inst[1].value).toEqual(tempName(0) + ".val");
          });
          it("maps between cases wrapped in functions and index into the statements", function() {
            var bytecode, switchStatement;
            bytecode = getStatementsBytecode("switch (val) {" + "case first:" + "  a = 2;" + "  a++;" + "case \"second\":" + "case false:" + "  a = 8;" + "  a++;" + "case foo():" + "  a = 11;" + "}");
            expect(bytecode.instructions.length).toEqual(1);
            switchStatement = bytecode.instructions[0];
            expectFunctionDef(switchStatement.cases[0].test, null, [], "return first", null);
            expectFunctionDef(switchStatement.cases[1].test, null, [], "return \"second\"", null);
            expectFunctionDef(switchStatement.cases[2].test, null, [], "return false", null);
            expectFunctionDef(switchStatement.cases[3].test, null, [], "return foo()", null);
            expect(switchStatement.cases[0].index).toEqual(0);
            expect(switchStatement.cases[1].index).toEqual(2);
            expect(switchStatement.cases[2].index).toEqual(2);
            return expect(switchStatement.cases[3].index).toEqual(4);
          });
          return it("stores a default index", function() {
            var bytecode;
            bytecode = getStatementsBytecode("switch (val) {" + "case \"foo\":" + "  a = 2;" + "}");
            expect(bytecode.instructions[0]["default"]).toBeNull();
            bytecode = getStatementsBytecode("switch (val) {" + "case \"foo\":" + "  a = 2;" + "default:" + "  a = 4;" + "case \"bar\":" + "  a = 6;" + "}");
            return expect(bytecode.instructions[0]["default"]).toEqual(1);
          });
        });
        it("creates break statements", function() {
          var breakStatement, bytecode, switchStatement;
          bytecode = getStatementsBytecode("switch (val) {" + "case \"foo\":" + "  break;" + "}");
          switchStatement = bytecode.instructions[0];
          breakStatement = switchStatement.instructions[0];
          return expect(breakStatement).toEqual(jasmine.any(evaluator.Break));
        });
        it("does not allow break statements to have labels", function() {
          var original;
          original = "" + "switch (val) {" + "case \"foo\":" + "  lbl:break lbl;" + "}";
          return expect(function() {
            return getStatementsBytecode(original);
          }).toThrow("Does not support labelled breaks.");
        });
        it("creates continue statements", function() {
          var bytecode, continueStatement, whileStatement;
          bytecode = getStatementsBytecode("while (true) {" + "  continue;" + "};");
          whileStatement = bytecode.instructions[0];
          continueStatement = whileStatement.instructions[1];
          return expect(continueStatement).toEqual(jasmine.any(evaluator.Continue));
        });
        it("doesn't allow labelled continues", function() {
          var original;
          original = "lbl:" + "while (true) {" + "  continue lbl;" + "};";
          return expect(function() {
            return getStatementsBytecode(original);
          }).toThrow("Does not support labelled continues.");
        });
        describe("creating While loops", function() {
          it("desugars it into a loop", function() {
            var bytecode, ifStatement, loop_;
            bytecode = getStatementsBytecode("while (!shouldStop()) {" + "  a = 1 + 2;" + "  a++;" + "}");
            expect(bytecode.instructions.length).toEqual(1);
            loop_ = bytecode.instructions[0];
            expect(loop_).toEqual(jasmine.any(evaluator.Loop));
            expect(loop_.instructions.length).toEqual(5);
            expectFunctionCall(loop_.instructions[0], "shouldStop", [], tempName(0));
            ifStatement = loop_.instructions[1];
            expect(ifStatement).toEqual(jasmine.any(evaluator.If));
            expectAstEqual(ifStatement.condition, "!!" + tempName(0));
            expect(ifStatement.thenCase.length).toEqual(1);
            expect(ifStatement.thenCase[0]).toEqual(jasmine.any(evaluator.Break));
            expect(ifStatement.elseCase).toEqual([]);
            expectAstEqual(loop_.instructions[2], "a = 1 + 2");
            expectAstEqual(loop_.instructions[3], "a++");
            return expect(loop_.instructions[4]).toEqual(jasmine.any(evaluator.Continue));
          });
          return it("uses function scope", function() {
            var bytecode;
            bytecode = getStatementsBytecode("while (true) {" + "  var a = 1 + 2;" + "  function b(c) {d};" + "}");
            expect(bytecode.declaredVariables).toEqual(["a"]);
            expect(bytecode.declaredFunctions.length).toEqual(1);
            return expectFunctionDef(bytecode.declaredFunctions[0], "b", ["c"], "d", null);
          });
        });
        describe("creating Do While loops", function() {
          it("desugars it into a loop", function() {
            var bytecode, ifStatement, loop_;
            bytecode = getStatementsBytecode("do {" + "  a = 1 + 2;" + "  a++;" + "} while (!shouldStop());");
            expect(bytecode.instructions.length).toEqual(1);
            loop_ = bytecode.instructions[0];
            expect(loop_).toEqual(jasmine.any(evaluator.Loop));
            expect(loop_.instructions.length).toEqual(5);
            expectAstEqual(loop_.instructions[0], "a = 1 + 2");
            expectAstEqual(loop_.instructions[1], "a++");
            expectFunctionCall(loop_.instructions[2], "shouldStop", [], tempName(0));
            ifStatement = loop_.instructions[3];
            expect(ifStatement).toEqual(jasmine.any(evaluator.If));
            expectAstEqual(ifStatement.condition, "!!" + tempName(0));
            expect(ifStatement.thenCase.length).toEqual(1);
            expect(ifStatement.thenCase[0]).toEqual(jasmine.any(evaluator.Break));
            expect(ifStatement.elseCase).toEqual([]);
            return expect(loop_.instructions[4]).toEqual(jasmine.any(evaluator.Continue));
          });
          return it("uses function scope", function() {
            var bytecode;
            bytecode = getStatementsBytecode("do {" + "  var a = 1 + 2;" + "  function b(c) {d};" + "} while (true);");
            expect(bytecode.declaredVariables).toEqual(["a"]);
            expect(bytecode.declaredFunctions.length).toEqual(1);
            return expectFunctionDef(bytecode.declaredFunctions[0], "b", ["c"], "d", null);
          });
        });
        return describe("creating For loops", function() {
          it("desugars it into a flat loop", function() {
            var bytecode, ifStatement, loop_;
            bytecode = getStatementsBytecode("" + "for (i = initVar(); i !== lst().length; i++) {" + "  a.push(i + 1);" + "}");
            expect(bytecode.instructions.length).toEqual(3);
            expectFunctionCall(bytecode.instructions[0], "initVar", [], tempName(0));
            expectAstEqual(bytecode.instructions[1], "i = " + tempName(0));
            loop_ = bytecode.instructions[2];
            expect(loop_).toEqual(jasmine.any(evaluator.Loop));
            expect(loop_.instructions.length).toEqual(6);
            expectFunctionCall(loop_.instructions[0], "lst", [], tempName(0));
            ifStatement = loop_.instructions[1];
            expect(ifStatement).toEqual(jasmine.any(evaluator.If));
            expectAstEqual(ifStatement.condition, "!(i !== " + tempName(0) + ".length)");
            expect(ifStatement.thenCase.length).toEqual(1);
            expect(ifStatement.thenCase[0]).toEqual(jasmine.any(evaluator.Break));
            expect(ifStatement.elseCase).toEqual([]);
            expectFunctionCall(loop_.instructions[2], "a.push", ["i + 1"], tempName(0));
            expectAstEqual(loop_.instructions[3], tempName(0));
            expectAstEqual(loop_.instructions[4], "i++");
            return expect(loop_.instructions[5]).toEqual(jasmine.any(evaluator.Continue));
          });
          it("uses function scope", function() {
            var bytecode;
            bytecode = getStatementsBytecode("for (var i = init; i != 0; --i) {" + "  var a = 1 + 2;" + "  function b(c) {d};" + "};");
            expect(bytecode.declaredVariables).toEqual(["i", "a"]);
            expect(bytecode.declaredFunctions.length).toEqual(1);
            return expectFunctionDef(bytecode.declaredFunctions[0], "b", ["c"], "d", null);
          });
          return it("handles empty expressions in loop definition", function() {
            var bytecode, forLoop;
            bytecode = getStatementsBytecode("for (; b; c) {}");
            expect(bytecode.instructions.length).toEqual(1);
            forLoop = bytecode.instructions[0];
            expect(forLoop).toEqual(jasmine.any(evaluator.Loop));
            expect(forLoop.instructions.length).toEqual(3);
            expect(forLoop.instructions[0]).toEqual(jasmine.any(evaluator.If));
            expectAstEqual(forLoop.instructions[0].condition, "!b");
            expect(forLoop.instructions[0].thenCase).toEqual([jasmine.any(evaluator.Break)]);
            expect(forLoop.instructions[0].elseCase).toEqual([]);
            expect(forLoop.instructions[1]).toEqual("c");
            expect(forLoop.instructions[2]).toEqual(jasmine.any(evaluator.Continue));
            bytecode = getStatementsBytecode("for (a; ; c) {}");
            expect(bytecode.instructions.length).toEqual(2);
            expect(bytecode.instructions[0]).toEqual("a");
            forLoop = bytecode.instructions[1];
            expect(forLoop).toEqual(jasmine.any(evaluator.Loop));
            expect(forLoop.instructions.length).toEqual(2);
            expect(forLoop.instructions[0]).toEqual("c");
            expect(forLoop.instructions[1]).toEqual(jasmine.any(evaluator.Continue));
            bytecode = getStatementsBytecode("for (a; b; ) {}");
            expect(bytecode.instructions.length).toEqual(2);
            expect(bytecode.instructions[0]).toEqual("a");
            forLoop = bytecode.instructions[1];
            expect(forLoop).toEqual(jasmine.any(evaluator.Loop));
            expect(forLoop.instructions.length).toEqual(2);
            expect(forLoop.instructions[0]).toEqual(jasmine.any(evaluator.If));
            expectAstEqual(forLoop.instructions[0].condition, "!b");
            expect(forLoop.instructions[0].thenCase).toEqual([jasmine.any(evaluator.Break)]);
            expect(forLoop.instructions[0].elseCase).toEqual([]);
            return expect(forLoop.instructions[1]).toEqual(jasmine.any(evaluator.Continue));
          });
        });
      });
    });
    return describe("when interpreting bytecode", function() {
      it("uses its context to evaluate non-function expressions", function() {
        var expressions, num, testId;
        num = 5;
        testId = {
          foo: "foo value",
          bar: "bar value",
          0: "zero value",
          9: "num value"
        };
        evaluator.context.setValue("num", num);
        evaluator.context.setValue("testId", testId);
        expressions = [
          ["\"my string\"", "my string"], ["true", true], ["null", null], ["123.45", 123.45], ["1.0e2", 1.0e2], ["/regex/", /regex/], ["testId", testId], ["[1, true, \"hi\", testId]", [1, true, "hi", testId]], [
            "({a: 1})", {
              a: 1
            }
          ], [
            "({msg: \"hello\", arr: [1,2,3], obj: {foo: \"bar\"}})", {
              msg: "hello",
              arr: [1, 2, 3],
              obj: {
                foo: "bar"
              }
            }
          ], ["1, 2, \"red\", \"blue\"", (1, 2, "red", "blue")], ["-num", -5], ["+5", 5], ["!\"hey\"", false], ["typeof testId", "object"], ["void \"hi\"", undefined], ["num in testId", false], ["\"0\" == false", true], ["foo = 12", 12], ["num += 4", 9], ["foo++", 12], ["++foo", 14], ["true || false", true], ["true ? \" \" : \"\"", " "], ["testId.foo", "foo value"], ["testId[\"bar\"]", "bar value"], ["testId[0]", "zero value"], ["testId[num]", "num value"], ["(1 + 2) * 3", 9], ["false && true || true", true], ["false && (true || true)", false]
        ];
        return $.each(expressions, function(i, pair) {
          var evaluated, inputString, outputValue;
          inputString = pair[0];
          outputValue = pair[1];
          evaluated = evaluator["eval"](inputString);
          return expect(evaluated).toEqual(outputValue);
        });
      });
      it("conditionally executes code in If blocks", function() {
        var program;
        program = "" + "a = 0;" + "if (val) {" + "  a += 1;" + "} else {" + "  a += 2;" + "}" + "a;";
        evaluator["eval"]("val = true");
        expect(evaluator["eval"](program)).toEqual(1);
        evaluator["eval"]("val = false");
        return expect(evaluator["eval"](program)).toEqual(2);
      });
      it("can break out of loops", function() {
        var program;
        program = "" + "a = 0;" + "while (true) {" + "  break;" + "  a = 1;" + "}" + "a;";
        return expect(evaluator["eval"](program)).toEqual(0);
      });
      it("can break out of nested blocks", function() {
        var program;
        program = "" + "a = 0;" + "while (true) {" + "  if (true) break;" + "  a = 1;" + "}" + "a;";
        expect(evaluator["eval"](program)).toEqual(0);
        program = "" + "a = 0;" + "do {" + "  while (true) {" + "    if (true) break;" + "    a += 1;" + "  }" + "  a += 2" + "} while (false)" + "a;";
        return expect(evaluator["eval"](program)).toEqual(2);
      });
      it("can continue in loops", function() {
        var program;
        program = "" + "a = 0;" + "while (true) {" + "  if (a > 0) break;" + "  a++;" + "  continue;" + "  a = 5;" + "}" + "a;";
        return expect(evaluator["eval"](program)).toEqual(1);
      });
      it("can continue in nested blocks", function() {
        var program;
        program = "" + "a = 0;" + "while (true) {" + "  if (a > 0) break;" + "  a++;" + "  if (true) continue;" + "  a = 5;" + "}" + "a;";
        return expect(evaluator["eval"](program)).toEqual(1);
      });
      it("repeats loops normally", function() {
        var program;
        program = "" + "a = 0;" + "while (a != 3) {" + "  a++;" + "}" + "a;";
        expect(evaluator["eval"](program)).toEqual(3);
        program = "" + "arr = [1,2,3];" + "for (i = 0; i < arr.length; i++) {" + "  arr[i] *= arr[i];" + "}" + "arr;";
        return expect(evaluator["eval"](program)).toEqual([1, 4, 9]);
      });
      it("will call native functions", function() {
        var myNativeFunc;
        myNativeFunc = jasmine.createSpy().andReturn(12);
        evaluator.context.setValue("myNativeFunc", myNativeFunc);
        expect(evaluator["eval"]("myNativeFunc(\"hi\", false)")).toEqual(12);
        return expect(myNativeFunc).toHaveBeenCalledWith("hi", false);
      });
      it("can define and call user functions", function() {
        var program;
        program = "" + "o = {foo: 1};" + "f = function () {" + "  o.foo += 1;" + "};" + "f();" + "o;";
        return expect(evaluator["eval"](program)).toEqual({
          foo: 2
        });
      });
      it("uses function scope when calling functions", function() {
        var program;
        program = "" + "a = 1;" + "b = 2;" + "c = 3;" + "f = function (a) {" + "  a += 1;" + "  var b = 6;" + "  c = a + b;" + "};" + "f(4);" + "[a, b, c];";
        evaluator["eval"]("val = 3");
        return expect(evaluator["eval"](program)).toEqual([1, 2, 11]);
      });
      it("can return values", function() {
        var program;
        program = "" + "increment = function (val) {" + "  return val + 1;" + "};" + "increment(5);";
        return expect(evaluator["eval"](program)).toEqual(6);
      });
      it("handles nested functions and has closures", function() {
        var program;
        program = "" + "counter = function () {" + "  var count = 0;" + "  return function () {" + "    return count++;" + "  };" + "};" + "firstCounter = counter();" + "firstRes = [];" + "firstRes.push(firstCounter());" + "firstRes.push(firstCounter());" + "secondCounter = counter();" + "secondRes = [];" + "secondRes.push(secondCounter());" + "firstRes.push(firstCounter());" + "secondRes.push(secondCounter());" + "secondRes.push(secondCounter());" + "firstRes.push(firstCounter());" + "firstRes.push(firstCounter());" + "[firstRes, secondRes]";
        return expect(evaluator["eval"](program)).toEqual([[0, 1, 2, 3, 4], [0, 1, 2]]);
      });
      xit("jumps to the correct case in a switch statement", function() {
        var program;
        program = "" + "a = 0;" + "switch (val) {" + "case 0:" + "  a += 1;" + "  break;" + "case 1:" + "  a += 2;" + "case 2:" + "  a += 3;" + "  break;" + "}" + "a;";
        evaluator["eval"]("val = 0");
        expect(evaluator["eval"](program)).toEqual(1);
        evaluator["eval"]("val = 1");
        expect(evaluator["eval"](program)).toEqual(5);
        evaluator["eval"]("val = 2");
        expect(evaluator["eval"](program)).toEqual(3);
        evaluator["eval"]("val = 3");
        return expect(evaluator["eval"](program)).toEqual(0);
      });
      xit("will use the default case in a switch if no other cases match", function() {
        var program;
        program = "" + "a = 0;" + "switch (val) {" + "case 0:" + "  a += 1;" + "default:" + "  a += 2;" + "case 1:" + "  a += 3;" + "}" + "a;";
        evaluator["eval"]("val = 0");
        expect(evaluator["eval"](program)).toEqual(6);
        evaluator["eval"]("val = 1");
        expect(evaluator["eval"](program)).toEqual(3);
        evaluator["eval"]("val = 2");
        return expect(evaluator["eval"](program)).toEqual(5);
      });
      return it("can pause execution", function() {
        var myObject, pauseExecFunc, program;
        pauseExecFunc = function() {
          return evaluator.pause();
        };
        myObject = {
          val: 0
        };
        evaluator.context.setValue("pauseExecFunc", pauseExecFunc);
        evaluator.context.setValue("myObject", myObject);
        program = "" + "f = function () {" + "  myObject.val = 1;" + "  pauseExecFunc();" + "  myObject.val = 2;" + "};" + "f();" + "pauseExecFunc();" + "myObject.val = 3;";
        evaluator["eval"](program);
        expect(myObject.val).toEqual(1);
        evaluator.resume();
        expect(myObject.val).toEqual(2);
        evaluator.resume();
        return expect(myObject.val).toEqual(3);
      });
    });
  });

}).call(this);
